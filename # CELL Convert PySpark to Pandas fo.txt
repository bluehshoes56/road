# =============================================================================
# CTVAE TRAINING ENGINE (CONDITIONAL TVAE)
# Uses TVAESynthesizer (NOT CTGANSynthesizer) with full configuration
# =============================================================================

def train_production_ctvae(df, conditional_column, epochs, compress_dims, decompress_dims, l2_scale, batch_size, loss_factor):
    """Train production CTVAE with comprehensive configuration"""
    
    if df is None or len(df) == 0:
        raise ValueError("No training data for CTVAE")
    
    print(f"\nüöÄ CTVAE TRAINING ENGINE")
    print(f"Model: TVAESynthesizer (Conditional TVAE, NOT CTGAN)")
    print(f"Training Data: {len(df):,} rows")
    print(f"Conditional Column: {conditional_column}")
    print(f"Configuration:")
    print(f"  epochs={epochs}, compress_dims={compress_dims}")
    print(f"  decompress_dims={decompress_dims}, l2scale={l2_scale}")
    print(f"  batch_size={batch_size}, loss_factor={loss_factor}")
    
    # Validate conditional column
    if conditional_column not in df.columns:
        raise ValueError(f"Conditional column '{conditional_column}' not found")
    
    unique_conditions = df[conditional_column].nunique()
    condition_values = sorted(df[conditional_column].unique())
    
    print(f"\nüìä Conditional Analysis:")
    print(f"  Conditions: {unique_conditions} unique values")
    print(f"  Values: {condition_values[:10]}{'...' if len(condition_values) > 10 else ''}")
    
    # Show condition distribution
    condition_dist = df[conditional_column].value_counts().sort_index()
    print(f"\nüìà Condition Distribution (Top 10):")
    for condition, count in condition_dist.head(10).items():
        pct = (count / len(df)) * 100
        print(f"  {condition}: {count:,} rows ({pct:.1f}%)")
    
    # Prepare features (exclude metadata)
    exclude_columns = ['weight', 'tier', 'importance_score']
    feature_columns = [col for col in df.columns if col not in exclude_columns]
    training_features = df[feature_columns].copy()
    
    print(f"\nüìã Training Features: {len(feature_columns)} columns")
    print(f"  Excluded metadata: {exclude_columns}")
    
    # Create metadata for CTVAE
    print(f"\nüîß Creating CTVAE metadata...")
    metadata = SingleTableMetadata()
    metadata.detect_from_dataframe(training_features)
    
    # Configure data types
    categorical_columns = [
        'payer_Company_Name', 'payee_Company_Name', 'payer_industry', 'payee_industry',
        'payer_GICS', 'payee_GICS', 'payer_subindustry', 'payee_subindustry', 'day_flag'
    ]
    
    numerical_columns = ['ed_amount', 'fh_file_creation_date', 'fh_file_creation_time']
    
    # Update metadata with constraints
    for col in categorical_columns:
        if col in training_features.columns:
            metadata.update_column(col, sdtype='categorical')
    
    # FIXED: Add explicit constraints for numerical columns, especially ed_amount
    for col in numerical_columns:
        if col in training_features.columns:
            if col == 'ed_amount':
                # Add explicit range constraints for ed_amount to preserve scale
                actual_min = float(training_features[col].min())
                actual_max = float(training_features[col].max())
                print(f"  Setting ed_amount constraints: ${actual_min:.2f} to ${actual_max:,.2f}")
                
                metadata.update_column(col, sdtype='numerical')
                # Force the CTVAE to respect actual amount ranges
                metadata.add_column_constraint(
                    column_name=col,
                    constraint_class='Range',
                    constraint_parameters={
                        'low_value': actual_min,
                        'high_value': actual_max,
                        'strict_boundaries': True
                    }
                )
            else:
                metadata.update_column(col, sdtype='numerical')
    
    # Validate metadata configuration
    categorical_count = len([col for col in training_features.columns if metadata.columns[col]['sdtype'] == 'categorical'])
    numerical_count = len([col for col in training_features.columns if metadata.columns[col]['sdtype'] == 'numerical'])
    
    print(f"‚úì Metadata configured: {categorical_count} categorical, {numerical_count} numerical")
    
    # Initialize CTVAE with full configuration
    print(f"\nüîß Initializing CTVAE (TVAESynthesizer)...")
    try:
        synthesizer = TVAESynthesizer(
            metadata=metadata,
            epochs=epochs,
            compress_dims=compress_dims,
            decompress_dims=decompress_dims,
            l2scale=l2_scale,
            batch_size=batch_size,
            loss_factor=loss_factor,
            verbose=True
        )
        print(f"‚úì CTVAE initialized with full configuration")
    except Exception as e:
        print(f"‚ö†Ô∏è Full config failed: {e}")
        print(f"Trying basic configuration...")
        synthesizer = TVAESynthesizer(
            metadata=metadata,
            epochs=epochs,
            verbose=True
        )
        print(f"‚úì CTVAE initialized with basic configuration")
    
    # Start training
    print(f"\nüéØ STARTING CTVAE TRAINING...")
    estimated_time = epochs * len(training_features) / (batch_size * 1000)
    print(f"Estimated time: {estimated_time:.1f} minutes")
    
    start_time = datetime.now()
    
    try:
        synthesizer.fit(training_features)
        
        training_time = datetime.now() - start_time
        print(f"\n‚úÖ CTVAE TRAINING SUCCESS")
        print(f"Training Time: {training_time.total_seconds() / 60:.1f} minutes")
        print(f"Model: {type(synthesizer).__name__}")
        print(f"Trained on {len(training_features):,} samples with {unique_conditions} conditions")
        
        return synthesizer, metadata
        
    except Exception as e:
        print(f"\n‚ùå CTVAE TRAINING ERROR: {e}")
        raise

# Train CTVAE model
try:
    ctvae_model, model_metadata = train_production_ctvae(
        training_data_weighted,
        CONDITIONAL_COLUMN,
        CTVAE_EPOCHS,
        COMPRESS_DIMS,
        DECOMPRESS_DIMS,
        L2_SCALE,
        BATCH_SIZE,
        LOSS_FACTOR
    )
    
    print(f"\nüéâ CTVAE MODEL READY")
    print(f"Model Type: {type(ctvae_model).__name__}")
    print(f"Conditional Column: {CONDITIONAL_COLUMN}")
    print(f"Available Conditions: {sorted(training_data_weighted[CONDITIONAL_COLUMN].unique())[:10]}")
    print(f"Ready for conditional synthetic data generation")
    
except Exception as e:
    print(f"‚ùå CTVAE training failed: {e}")
    raise
