# COMMAND ----------
# Fixed Quarterly Tracking: Count and Analyze Remaining Merchants from Original 14-Month Sample

from pyspark.sql.functions import col, countDistinct, sum as spark_sum, avg, when, lit, broadcast
import pandas as pd

# Configuration
QUARTER_INTERVAL = 6  # Semi-annual reporting
OUTPUT_PATH = "/dbfs/FileStore/output/"

print("Quarterly Tracking: Remaining Merchants from Original 14-Month Sample")
print(f"Interval: Every {QUARTER_INTERVAL} months")

# COMMAND ----------
# Define 14-month constant period
period2_months = [202101, 202102, 202103, 202104, 202105, 202106, 
                  202107, 202108, 202109, 202110, 202111, 202112, 
                  202201, 202202]  # Jan 2021 - Feb 2022

# Get available months for tracking
available_months = gbs_mids_joined.select("txn_year_month").distinct().collect()
available_months_list = sorted([row.txn_year_month for row in available_months])

# Define future tracking periods based on available data
tracking_months = []
expected_tracking_months = []

# Generate expected quarterly periods (for reference)
start_year = 2022
end_year = 2025  # Reasonable upper bound
for year in range(start_year, end_year + 1):
    if QUARTER_INTERVAL == 6:
        for month in [6, 12]:
            period = year * 100 + month
            if period > 202202:  # After Feb 2022
                expected_tracking_months.append(period)
    elif QUARTER_INTERVAL == 3:
        for month in [3, 6, 9, 12]:
            period = year * 100 + month
            if period > 202202:
                expected_tracking_months.append(period)

# Filter to only include periods where data actually exists
for expected_period in expected_tracking_months:
    if expected_period in available_months_list:
        tracking_months.append(expected_period)

print(f"Original 14-month period: {period2_months[0]} to {period2_months[-1]}")
print(f"Expected tracking periods: {expected_tracking_months[:10]}...")  # Show first 10
print(f"Available tracking periods: {tracking_months}")

if not tracking_months:
    print("WARNING: No future quarterly data available beyond Feb 2022")
    print("Analysis will only show baseline (Feb 2022) metrics")
elif len(tracking_months) < len(expected_tracking_months[:6]):  # Check first 6 expected
    missing_count = len(expected_tracking_months[:6]) - len(tracking_months)
    latest_available = max(available_months_list) if available_months_list else 202202
    print(f"NOTE: Data availability ends at {latest_available}")
    print(f"Missing {missing_count} expected quarterly periods - analysis shows available data only")

# COMMAND ----------
# Identify the original 14-month constant merchants
print("Identifying original 14-month constant merchants...")

period2_data = gbs_mids_joined.filter(col("txn_year_month").isin(period2_months))
merchants_14m_counts = period2_data.groupBy("merchant_key").agg(
    countDistinct("txn_year_month").alias("months_present")
)
original_constant_merchants = merchants_14m_counts.filter(col("months_present") == 14).select("merchant_key")
original_sample_count = original_constant_merchants.count()

print(f"Original 14-month constant merchants: {original_sample_count:,}")

# COMMAND ----------
# Analyze remaining merchants for each tracking period
print("Analyzing remaining merchants in future periods...")

all_results = []
all_periods = [202202] + tracking_months  # Include baseline

for period in all_periods:
    print(f"Processing period: {period}")
    
    # Check if this period actually exists in the data
    period_exists = period in available_months_list
    if not period_exists:
        print(f"  WARNING: Period {period} not found in available data - skipping")
        continue
    
    # Get merchants from original sample who are still present
    period_data = gbs_mids_joined.filter(col("txn_year_month") == period)
    
    # Check if any data exists for this period
    total_rows_in_period = period_data.count()
    if total_rows_in_period == 0:
        print(f"  WARNING: No transaction data found for period {period} - skipping")
        continue
    
    remaining_merchants = period_data.join(broadcast(original_constant_merchants), on="merchant_key", how="inner")
    remaining_count = remaining_merchants.select("merchant_key").distinct().count()
    
    print(f"  Remaining merchants: {remaining_count:,} out of {original_sample_count:,}")
    
    if remaining_count > 0:
        # Calculate statistics by NAICS3
        naics3_stats = remaining_merchants.groupBy("naics3").agg(
            countDistinct("merchant_key").alias("remaining_merchants"),
            spark_sum("adjusted_txn_cnt").alias("total_transactions"),
            spark_sum("total_tran_amount").alias("total_amount")
        ).withColumn("period", lit(period)) \
         .withColumn("avg_amount_per_txn", 
                     when(col("total_transactions") > 0, 
                          col("total_amount") / col("total_transactions")).otherwise(0)) \
         .withColumn("avg_amount_per_merchant", 
                     when(col("remaining_merchants") > 0, 
                          col("total_amount") / col("remaining_merchants")).otherwise(0))
        
        naics3_pd = naics3_stats.toPandas()
        naics3_pd['original_sample_count'] = original_sample_count
        naics3_pd['total_remaining'] = remaining_count
        all_results.append(naics3_pd)
    else:
        print(f"  No remaining merchants found in period {period} - natural attrition complete")

# COMMAND ----------
# Process results and create output tables
if all_results:
    quarterly_df = pd.concat(all_results, ignore_index=True)
    
    # Calculate retention percentages
    quarterly_df['retention_pct'] = (quarterly_df['total_remaining'] / quarterly_df['original_sample_count'] * 100).round(1)
    
    # Get unique periods and NAICS for display
    naics3_list = sorted(quarterly_df['naics3'].unique())
    period_list = sorted(quarterly_df['period'].unique())
    
    print(f"\n{'='*120}")
    print(f"REMAINING MERCHANTS QUARTERLY TRACKING ({QUARTER_INTERVAL}-MONTH INTERVALS)")
    print(f"Original sample: {original_sample_count:,} merchants from 14-month constant period")
    print(f"{'='*120}")
    
    # Summary by period
    print("\nSUMMARY BY PERIOD:")
    print("-" * 80)
    print(f"{'Period':<10} | {'Remaining':<12} | {'Retention %':<12} | {'Total Amount':<15} | {'Total Txns':<12}")
    print("-" * 80)
    
    for period in period_list:
        period_data = quarterly_df[quarterly_df['period'] == period]
        if len(period_data) > 0:
            total_remaining = int(period_data['total_remaining'].iloc[0])
            total_amount = period_data['total_amount'].sum()
            total_txns = period_data['total_transactions'].sum()
            retention_pct = (total_remaining / original_sample_count * 100)
            
            period_label = "Baseline" if period == 202202 else str(period)
            
            print(f"{period_label:<10} | {total_remaining:,} | {retention_pct:.1f}% | ${total_amount:,.0f} | {total_txns:,.0f}")
    
    # Detailed breakdown by NAICS3
    metrics = [
        ('REMAINING MERCHANT COUNTS', 'remaining_merchants'),
        ('TOTAL TRANSACTION AMOUNT', 'total_amount'),
        ('TOTAL TRANSACTION COUNT', 'total_transactions'),
        ('AVERAGE AMOUNT PER TRANSACTION', 'avg_amount_per_txn'),
        ('AVERAGE AMOUNT PER MERCHANT', 'avg_amount_per_merchant')
    ]
    
    for metric_name, metric_col in metrics:
        print(f"\n{metric_name}:")
        print("-" * 120)
        
        # Create header
        header = f"{'NAICS3':<8}"
        for period in period_list:
            header += f" | {period:<15}"
        print(header)
        print("-" * 120)
        
        # Create rows for each NAICS3 (top 15)
        for naics3 in naics3_list[:15]:
            naics_data = quarterly_df[quarterly_df['naics3'] == naics3]
            row = f"{naics3:<8}"
            
            for period in period_list:
                period_data = naics_data[naics_data['period'] == period]
                
                if len(period_data) > 0:
                    raw_value = period_data[metric_col].iloc[0]
                    
                    if metric_col in ['total_amount', 'avg_amount_per_txn', 'avg_amount_per_merchant']:
                        value = f"{raw_value:,.0f}"
                    else:
                        value = f"{int(raw_value):,}"
                else:
                    value = "0"
                
                row += f" | {value:<15}"
            
            print(row)

# COMMAND ----------
# Retention trend analysis
if all_results and len(period_list) > 1:
    print(f"\n{'='*80}")
    print("RETENTION TREND ANALYSIS")
    print(f"{'='*80}")
    
    baseline_count = int(quarterly_df[quarterly_df['period'] == period_list[0]]['total_remaining'].iloc[0])
    print(f"Starting merchants (Feb 2022): {baseline_count:,}")
    
    for i, period in enumerate(period_list[1:], 1):
        current_count = int(quarterly_df[quarterly_df['period'] == period]['total_remaining'].iloc[0])
        retention_vs_baseline = (current_count / baseline_count * 100)
        retention_vs_original = (current_count / original_sample_count * 100)
        
        print(f"{period}: {current_count:,} merchants")
        print(f"  Retention vs Feb 2022: {retention_vs_baseline:.1f}%")
        print(f"  Retention vs original sample: {retention_vs_original:.1f}%")
        
        if i > 1:
            prev_period = period_list[i-1]
            prev_count = int(quarterly_df[quarterly_df['period'] == prev_period]['total_remaining'].iloc[0])
            period_change = (current_count / prev_count * 100)
            print(f"  Change from previous period: {period_change:.1f}%")
        print()

# COMMAND ----------
# Export results
print(f"=== EXPORTING RESULTS ===")

try:
    if all_results:
        # Export detailed quarterly data
        quarterly_df.to_csv(f"{OUTPUT_PATH}remaining_merchants_quarterly.csv", index=False)
        print(f"✓ Exported: remaining_merchants_quarterly.csv")
        
        # Create summary pivot table
        merchant_counts_pivot = quarterly_df.pivot(index='naics3', columns='period', values='remaining_merchants').fillna(0)
        merchant_counts_pivot.to_csv(f"{OUTPUT_PATH}remaining_merchants_pivot.csv")
        print(f"✓ Exported: remaining_merchants_pivot.csv")
        
        # Create retention summary
        retention_summary = []
        for period in period_list:
            period_data = quarterly_df[quarterly_df['period'] == period]
            if len(period_data) > 0:
                total_remaining = int(period_data['total_remaining'].iloc[0])
                total_amount = period_data['total_amount'].sum()
                total_txns = period_data['total_transactions'].sum()
                
                retention_summary.append({
                    'period': period,
                    'remaining_merchants': total_remaining,
                    'retention_percentage': (total_remaining / original_sample_count * 100),
                    'total_amount': total_amount,
                    'total_transactions': total_txns,
                    'avg_amount_per_merchant': total_amount / total_remaining if total_remaining > 0 else 0,
                    'avg_amount_per_txn': total_amount / total_txns if total_txns > 0 else 0
                })
        
        retention_df = pd.DataFrame(retention_summary)
        retention_df.to_csv(f"{OUTPUT_PATH}retention_summary.csv", index=False)
        print(f"✓ Exported: retention_summary.csv")
        
    print(f"All files saved to: {OUTPUT_PATH}")

except Exception as e:
    print(f"Export error: {e}")

# COMMAND ----------
print("\n" + "="*100)
print("REMAINING MERCHANTS QUARTERLY TRACKING COMPLETED")
print("="*100)

if all_results:
    final_period = period_list[-1] if period_list else None
    final_count = int(quarterly_df[quarterly_df['period'] == final_period]['total_remaining'].iloc[0]) if final_period else 0
    final_retention = (final_count / original_sample_count * 100)
    
    print(f"✓ Original sample: {original_sample_count:,} merchants")
    print(f"✓ Periods tracked: {len(period_list)} periods")
    print(f"✓ Final period ({final_period}): {final_count:,} remaining merchants")
    print(f"✓ Overall retention: {final_retention:.1f}%")
    
    if len(period_list) > 1:
        total_amount_latest = quarterly_df[quarterly_df['period'] == final_period]['total_amount'].sum()
        total_txns_latest = quarterly_df[quarterly_df['period'] == final_period]['total_transactions'].sum()
        
        if total_txns_latest > 0:
            avg_per_txn = total_amount_latest / total_txns_latest
            print(f"✓ Latest period avg per transaction: ${avg_per_txn:,.0f}")
        
        if final_count > 0:
            avg_per_merchant = total_amount_latest / final_count
            print(f"✓ Latest period avg per merchant: ${avg_per_merchant:,.0f}")

print(f"\nResults show merchant persistence from original {original_sample_count:,} sample")
print(f"Ready for extrapolation analysis with real merchant retention data")
